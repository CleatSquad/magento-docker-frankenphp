---
name: Generate Release Notes

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  generate-release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    if: |
      github.event.issue.pull_request &&
      contains(github.event.comment.body, '@bot generate-release-note')
    steps:
      - name: Add reaction to comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });

      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            core.setOutput('number', pr.data.number);
            core.setOutput('title', pr.data.title);
            core.setOutput('body', pr.data.body || '');
            core.setOutput('head_ref', pr.data.head.ref);
            core.setOutput('base_ref', pr.data.base.ref);
            return pr.data;

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr.outputs.head_ref }}
          fetch-depth: 0

      - name: Get changed files
        id: changes
        run: |
          # Get list of changed files in PR
          CHANGED_FILES=$(git diff --name-only origin/${{ steps.pr.outputs.base_ref }}...HEAD | head -50)
          echo "files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED_FILES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get commit messages
        id: commits
        run: |
          # Get commit messages from PR
          COMMITS=$(git log --oneline origin/${{ steps.pr.outputs.base_ref }}...HEAD | head -20)
          echo "messages<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check existing release notes
        id: existing
        run: |
          PR_NUMBER=${{ steps.pr.outputs.number }}
          NOTES_FILE=".release-notes/pr-${PR_NUMBER}.md"
          if [ -f "$NOTES_FILE" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            CONTENT=$(cat "$NOTES_FILE")
            echo "content<<EOF" >> $GITHUB_OUTPUT
            echo "$CONTENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "content=" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes with AI
        id: generate
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const prTitle = `${{ steps.pr.outputs.title }}`;
            const prBody = `${{ steps.pr.outputs.body }}`.substring(0, 2000);
            const changedFiles = `${{ steps.changes.outputs.files }}`;
            const commits = `${{ steps.commits.outputs.messages }}`;
            const existingNotes = `${{ steps.existing.outputs.content }}`;
            const notesExist = '${{ steps.existing.outputs.exists }}' === 'true';

            // Analyze the changes to generate release notes
            let category = 'Changed';
            let releaseNotes = '';

            // Determine category based on files and title
            const lowerTitle = prTitle.toLowerCase();
            const lowerFiles = changedFiles.toLowerCase();

            if (lowerTitle.includes('fix') || lowerTitle.includes('bug')) {
              category = 'Fixed';
            } else if (lowerTitle.includes('feat') || lowerTitle.includes('add')) {
              category = 'Added';
            } else if (lowerTitle.includes('doc') || lowerFiles.includes('.md') || lowerFiles.includes('readme')) {
              category = 'Documentation';
            } else if (lowerTitle.includes('security') || lowerTitle.includes('vuln')) {
              category = 'Security';
            } else if (lowerTitle.includes('deprecat')) {
              category = 'Deprecated';
            } else if (lowerTitle.includes('remov') || lowerTitle.includes('delet')) {
              category = 'Removed';
            }

            // Generate bullet points from PR info
            let bullets = [];

            // Extract from PR body if it has bullet points
            if (prBody) {
              const bodyLines = prBody.split('\n');
              for (const line of bodyLines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('- ') && !trimmed.includes('[ ]') && !trimmed.includes('[x]')) {
                  const bullet = trimmed.substring(2).trim();
                  if (bullet.length > 10 && bullet.length < 200 && !bullet.toLowerCase().includes('n/a')) {
                    bullets.push(bullet);
                  }
                }
              }
            }

            // If no bullets from body, create from title
            if (bullets.length === 0) {
              bullets.push(prTitle);
            }

            // Limit to 5 bullets
            bullets = bullets.slice(0, 5);

            // Format release notes
            releaseNotes = `### ${category}\n\n`;
            for (const bullet of bullets) {
              releaseNotes += `- ${bullet}\n`;
            }

            core.setOutput('notes', releaseNotes);
            core.setOutput('category', category);
            return releaseNotes;

      - name: Create release notes directory
        run: mkdir -p .release-notes

      - name: Write release notes file
        run: |
          PR_NUMBER=${{ steps.pr.outputs.number }}
          NOTES_FILE=".release-notes/pr-${PR_NUMBER}.md"

          cat > "$NOTES_FILE" << 'NOTES_EOF'
          ${{ steps.generate.outputs.notes }}
          NOTES_EOF

          echo "Created/Updated: $NOTES_FILE"
          cat "$NOTES_FILE"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          PR_NUMBER=${{ steps.pr.outputs.number }}
          NOTES_FILE=".release-notes/pr-${PR_NUMBER}.md"

          git add "$NOTES_FILE"
          git diff --staged --quiet || git commit -m "docs: Generate release notes for PR #${PR_NUMBER}"
          git push origin ${{ steps.pr.outputs.head_ref }}

      - name: Add success reaction
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const category = '${{ steps.generate.outputs.category }}';
            const notesFile = `.release-notes/pr-${prNumber}.md`;

            const body = `### Release Notes Generated

            I've created/updated the release notes file: \`${notesFile}\`

            **Category detected:** ${category}

            Please review the file and make any necessary adjustments. The content will be automatically added to CHANGELOG.md when this PR is merged.

            <details>
            <summary>Preview</summary>

            \`\`\`markdown
            ${{ steps.generate.outputs.notes }}
            \`\`\`

            </details>`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });
